---
name: Deployment Guard

on:
  workflow_call:
    inputs:
      # Organization-based bypass configuration
      trusted_organization:
        description: 'GitHub organization name whose PUBLIC members can bypass all validations (e.g., dotCMS)'
        required: false
        type: string
        default: ''

      # Validation toggles - enable/disable specific checks
      enable_file_allowlist:
        description: 'Enable file allowlist validation'
        required: false
        type: boolean
        default: true
      enable_image_only_check:
        description: 'Enable image-only change validation (blocks if other fields changed)'
        required: false
        type: boolean
        default: true
      enable_image_validation:
        description: 'Enable image repository, format, and version validation'
        required: false
        type: boolean
        default: true

      # File allowlist configuration
      allowed_files_pattern:
        description: 'Glob pattern for allowed files (e.g., kubernetes/dotcms/**/statefulset.yaml)'
        required: false
        type: string
        default: '**/*'

      # Image validation configuration
      allowed_image_repositories:
        description: 'Comma-separated list of allowed image repositories (e.g., dotcms/dotcms)'
        required: false
        type: string
        default: ''
      allowed_version_pattern:
        description: 'Regex pattern for allowed version tags (default: any)'
        required: false
        type: string
        default: '.*'
      verify_image_existence:
        description: 'Whether to verify image exists in registry'
        required: false
        type: boolean
        default: true

      # Testing parameter
      testing_force_non_bypass:
        description: 'TESTING ONLY: Force non-bypass mode to test validation logic (ignores organization membership)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write

jobs:
  check-org-membership:
    name: Check Organization Membership
    runs-on: ubuntu-latest
    outputs:
      is-org-member: ${{ steps.check.outputs.is_member }}
      pr-author: ${{ steps.check.outputs.author }}
      should-bypass: ${{ steps.check.outputs.should_bypass }}
      organization: ${{ steps.check.outputs.organization }}
    steps:
      - name: Check if PR author is organization member
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const trustedOrg = '${{ inputs.trusted_organization }}';
            const actor = context.payload.pull_request.user.login;

            core.setOutput('author', actor);

            // If no organization configured, don't bypass
            if (!trustedOrg || trustedOrg.trim() === '') {
              console.log('‚ÑπÔ∏è  No trusted organization configured, running full validation');
              core.setOutput('is_member', false);
              core.setOutput('should_bypass', false);
              core.setOutput('organization', '');
              return;
            }

            console.log('');
            console.log('üîç Checking organization membership...');
            console.log(`   Organization: ${trustedOrg}`);
            console.log(`   User: ${actor}`);
            console.log('');

            let isTrusted = false;

            // TESTING MODE: Force non-bypass if testing parameter is enabled
            const testingForceNonBypass = '${{ inputs.testing_force_non_bypass }}' === 'true';

            if (testingForceNonBypass) {
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  TESTING MODE ENABLED');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  Forcing NON-BYPASS mode to test validation logic');
              console.log('‚ö†Ô∏è  Organization membership is being IGNORED for testing');
              console.log('‚ö†Ô∏è  This user will go through full validation');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('');

              isTrusted = false;
              core.setOutput('organization', 'testing-mode');
            } else {
              try {
                // Check if user is a PUBLIC member of the organization
                await github.rest.orgs.checkPublicMembershipForUser({
                  org: trustedOrg,
                  username: actor
                });

                console.log(`‚úÖ User ${actor} is a PUBLIC member of ${trustedOrg}`);
                console.log('üöÄ All validations will be BYPASSED');
                isTrusted = true;
                core.setOutput('organization', trustedOrg);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`‚ùå User ${actor} is NOT a public member of ${trustedOrg}`);
                  console.log('');
                  console.log('üìã TROUBLESHOOTING:');
                  console.log('   If you are a member of the organization:');
                  console.log(`   1. Visit https://github.com/orgs/${trustedOrg}/people`);
                  console.log('   2. Find your username in the list');
                  console.log('   3. Ensure your membership visibility is set to PUBLIC');
                  console.log('   4. Click "Make public" if your membership is currently private');
                  console.log('');
                  console.log('   If you are not listed, contact an organization owner to be added.');
                  console.log('');
                  console.log('üîí Full validation will be enforced');
                } else {
                  console.log(`‚ö†Ô∏è  Error checking organization membership: ${error.message}`);
                  console.log('‚ÑπÔ∏è  Treating as non-member, full validation will be enforced');
                }
                isTrusted = false;
                core.setOutput('organization', '');
              }
            }

            // Set outputs
            core.setOutput('is_member', isTrusted);
            core.setOutput('should_bypass', isTrusted);

            // Final result
            console.log('');
            if (isTrusted) {
              console.log(`‚úÖ RESULT: User ${actor} is a trusted ${trustedOrg} organization member`);
              console.log('üöÄ ALL VALIDATIONS WILL BE BYPASSED');
            } else {
              console.log(`‚ÑπÔ∏è  RESULT: User ${actor} is not a public member of ${trustedOrg}`);
              console.log('üîí FULL VALIDATION WILL BE ENFORCED');
            }

  validate-changed-files:
    name: Validate Changed Files
    runs-on: ubuntu-latest
    needs: check-org-membership
    if: |
      inputs.enable_file_allowlist &&
      needs.check-org-membership.outputs.should-bypass == 'false'
    outputs:
      allowed-files-check: ${{ steps.check-files.outputs.result }}
      changed-files: ${{ steps.get-files.outputs.files }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: get-files
        run: |
          # Get list of changed files in the PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # For push events, use event.before and event.after for correct commit range
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.event.after }}"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '\.ya?ml$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No YAML files changed"
            echo "files=[]" >> "$GITHUB_OUTPUT"
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert to JSON array for output
            FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "files=$FILES_JSON" >> "$GITHUB_OUTPUT"
          fi

      - name: Check files against allowlist
        id: check-files
        run: |
          set -euo pipefail

          CHANGED_FILES='${{ steps.get-files.outputs.files }}'
          ALLOWED_PATTERN='${{ inputs.allowed_files_pattern }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Validating files against pattern: $ALLOWED_PATTERN"

          # Convert glob pattern to regex
          PATTERN_REGEX=$(echo "$ALLOWED_PATTERN" | sed 's#\.ya?ml#\\.(yaml|yml)#g' | sed 's#\*\*/#__DOUBLESTAR__#g' | sed 's#\*#[^/]*#g' | sed 's#__DOUBLESTAR__#([^/]+/)*#g')

          # State variables (NO temporary files)
          VALIDATION_FAILED=false
          DISALLOWED_FILES=()

          while IFS= read -r file; do
            if ! echo "$file" | grep -qE "^${PATTERN_REGEX}$"; then
              echo "‚ùå File not allowed: $file"
              VALIDATION_FAILED=true
              DISALLOWED_FILES+=("$file")
            else
              echo "‚úÖ File allowed: $file"
            fi
          done < <(echo "$CHANGED_FILES" | jq -r '.[]')

          # Final result
          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo ""
            echo "‚ùå Validation failed for ${#DISALLOWED_FILES[@]} file(s):"
            printf '   - %s\n' "${DISALLOWED_FILES[@]}"
            echo "result=fail" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "‚úÖ All files are in the allowlist"
            echo "result=pass" >> "$GITHUB_OUTPUT"
          fi

  validate-image-only-changed:
    name: Validate Only Image Changed
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-changed-files]
    if: |
      always() &&
      inputs.enable_image_only_check &&
      needs.check-org-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_file_allowlist == false || needs.validate-changed-files.outputs.allowed-files-check == 'pass')
    outputs:
      image-only-check: ${{ steps.check-changes.outputs.result }}
      new-images: ${{ steps.check-changes.outputs.images }}
      old-images: ${{ steps.check-changes.outputs.old-images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check only image field changed
        id: check-changes
        run: |
          set -euo pipefail

          CHANGED_FILES='${{ needs.validate-changed-files.outputs.changed-files }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            echo "old-images=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_SHA="${{ github.event.pull_request.base.sha }}"

          # State variables (NO temporary files)
          VALIDATION_FAILED=false
          FAILED_FILES=()
          NEW_IMAGES=()
          OLD_IMAGES=()

          while IFS= read -r file; do
            echo "=================================================="
            echo "Validating: $file"
            echo "=================================================="

            # Get old and new YAML content
            OLD_YAML=$(git show "$BASE_SHA:$file" 2>/dev/null || echo "")
            NEW_YAML=$(cat "$file")

            if [ -z "$OLD_YAML" ]; then
              echo "‚ö†Ô∏è  File is new, skipping comparison"
              continue
            fi

            # Extract the main dotCMS container image
            OLD_IMAGE=$(echo "$OLD_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")
            NEW_IMAGE=$(echo "$NEW_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")

            if [ -z "$OLD_IMAGE" ] || [ -z "$NEW_IMAGE" ]; then
              echo "‚ùå Could not extract dotCMS container image"
              VALIDATION_FAILED=true
              FAILED_FILES+=("$file: Could not extract image")
              continue
            fi

            echo "Old image: $OLD_IMAGE"
            echo "New image: $NEW_IMAGE"

            # Normalize both YAMLs by replacing the dotCMS image with placeholder
            OLD_NORMALIZED=$(echo "$OLD_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')
            NEW_NORMALIZED=$(echo "$NEW_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')

            # Compare normalized YAMLs
            if [ "$OLD_NORMALIZED" != "$NEW_NORMALIZED" ]; then
              echo "‚ùå Changes detected beyond image field in: $file"
              echo ""
              echo "Diff of normalized files:"
              diff <(echo "$OLD_NORMALIZED") <(echo "$NEW_NORMALIZED") || true
              VALIDATION_FAILED=true
              FAILED_FILES+=("$file: Changes beyond image field")
            else
              echo "‚úÖ Only image changed: $OLD_IMAGE ‚Üí $NEW_IMAGE"
              NEW_IMAGES+=("$NEW_IMAGE")
              OLD_IMAGES+=("$OLD_IMAGE")
            fi
            echo ""
          done < <(echo "$CHANGED_FILES" | jq -r '.[]')

          # Final result
          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo ""
            echo "‚ùå Validation failed for ${#FAILED_FILES[@]} file(s):"
            printf '   - %s\n' "${FAILED_FILES[@]}"
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            echo "old-images=[]" >> "$GITHUB_OUTPUT"
            exit 1
          else
            # Convert arrays to JSON
            if [ ${#NEW_IMAGES[@]} -gt 0 ]; then
              IMAGES_JSON=$(printf '%s\n' "${NEW_IMAGES[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0)) | unique')
              echo "images=$IMAGES_JSON" >> "$GITHUB_OUTPUT"
            else
              echo "images=[]" >> "$GITHUB_OUTPUT"
            fi

            if [ ${#OLD_IMAGES[@]} -gt 0 ]; then
              OLD_IMAGES_JSON=$(printf '%s\n' "${OLD_IMAGES[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0)) | unique')
              echo "old-images=$OLD_IMAGES_JSON" >> "$GITHUB_OUTPUT"
            else
              echo "old-images=[]" >> "$GITHUB_OUTPUT"
            fi

            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files have only image field changes"
          fi

  validate-images:
    name: Validate Images
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-image-only-changed]
    if: |
      always() &&
      inputs.enable_image_validation &&
      needs.check-org-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_image_only_check == false || needs.validate-image-only-changed.outputs.image-only-check == 'pass')
    outputs:
      image-validation: ${{ steps.validate.outputs.result }}
    steps:
      - name: Validate image format, repository, tag, and existence
        id: validate
        run: |
          set -euo pipefail

          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          OLD_IMAGES='${{ needs.validate-image-only-changed.outputs.old-images }}'
          ALLOWED_REPOS='${{ inputs.allowed_image_repositories }}'
          VERSION_PATTERN='${{ inputs.allowed_version_pattern }}'
          VERIFY_EXISTENCE='${{ inputs.verify_image_existence }}'

          if [ "$NEW_IMAGES" = "" ] || [ "$NEW_IMAGES" = "[]" ]; then
            echo "No new images to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # State variables (NO temporary files)
          VALIDATION_FAILED=false
          FAILED_IMAGES=()

          # Create arrays from JSON
          mapfile -t NEW_IMAGES_ARRAY < <(echo "$NEW_IMAGES" | jq -r '.[]')
          mapfile -t OLD_IMAGES_ARRAY < <(echo "$OLD_IMAGES" | jq -r '.[]')

          # Process each new image
          for INDEX in "${!NEW_IMAGES_ARRAY[@]}"; do
            image="${NEW_IMAGES_ARRAY[$INDEX]}"

            echo "=================================================="
            echo "Validating image [$((INDEX + 1))/${#NEW_IMAGES_ARRAY[@]}]: $image"
            echo "=================================================="

            # 1. Validate format (repo/name:tag)
            if ! [[ "$image" =~ ^[a-zA-Z0-9/_.-]+:[a-zA-Z0-9_.-]+$ ]]; then
              echo "‚ùå Image format validation failed"
              echo "   Image: $image"
              echo "   REASON: Invalid image format (expected format: repository/name:tag)"
              VALIDATION_FAILED=true
              FAILED_IMAGES+=("$image: Invalid format")
              continue
            fi
            echo "‚úÖ Image format is valid"

            # 2. Extract repository and tag
            REPO="${image%:*}"
            TAG="${image##*:}"
            echo "   Full image: $image"
            echo "   Repository: $REPO"
            echo "   Tag: $TAG"

            # 3. Extract base repository name (handle both with and without registry prefix)
            BASE_REPO="$REPO"
            if [[ "$REPO" =~ / ]]; then
              # Check if REPO starts with a registry domain
              if [[ "$REPO" =~ ^[a-z0-9.-]+\.[a-z]{2,}/ ]] || [[ "$REPO" =~ ^gcr\.io/ ]] || [[ "$REPO" =~ ^.*\.gcr\.io/ ]]; then
                # Extract everything after the first slash (removes registry domain)
                BASE_REPO="${REPO#*/}"
              fi
            fi
            echo "   Base repository: $BASE_REPO"

            # 4. Check repository is in allowlist (if configured)
            if [ -n "$ALLOWED_REPOS" ]; then
              REPO_ALLOWED=false
              IFS=',' read -ra ALLOWED <<< "$ALLOWED_REPOS"
              for allowed_repo in "${ALLOWED[@]}"; do
                # Trim whitespace
                allowed_repo=$(echo "$allowed_repo" | xargs)

                echo "   Comparing '$BASE_REPO' with allowed '$allowed_repo'"
                if [[ "$BASE_REPO" == "$allowed_repo" ]] || [[ "$REPO" == "$allowed_repo" ]]; then
                  REPO_ALLOWED=true
                  echo "   ‚úì Match found"
                  break
                fi
              done

              if [ "$REPO_ALLOWED" = false ]; then
                echo "‚ùå Repository validation failed"
                echo "   Repository: $REPO"
                echo "   REASON: Repository is not in the allowlist"
                echo "   Allowed repositories: $ALLOWED_REPOS"
                VALIDATION_FAILED=true
                FAILED_IMAGES+=("$image: Repository not allowed")
                continue
              fi
              echo "‚úÖ Repository is allowed"
            else
              echo "‚ÑπÔ∏è  Repository validation skipped (no allowlist configured)"
            fi

            # 5. Validate tag matches version pattern
            if ! [[ "$TAG" =~ $VERSION_PATTERN ]]; then
              echo "‚ùå Version pattern validation failed"
              echo "   Tag: $TAG"
              echo "   Required pattern: $VERSION_PATTERN"
              echo "   REASON: Tag does not match the required version pattern"
              VALIDATION_FAILED=true
              FAILED_IMAGES+=("$image: Version pattern mismatch")
              continue
            fi
            echo "‚úÖ Tag matches version pattern"

            # 6. Anti-downgrade validation (compare versions)
            if [ "$INDEX" -lt "${#OLD_IMAGES_ARRAY[@]}" ]; then
              OLD_IMAGE="${OLD_IMAGES_ARRAY[$INDEX]}"
              OLD_TAG="${OLD_IMAGE##*:}"

              echo ""
              echo "Checking for downgrades..."
              echo "   Old tag: $OLD_TAG"
              echo "   New tag: $TAG"

              # Parse version components
              # Format: YY.MM.DD[-REBUILD][_HASH]
              # Examples: 25.12.08, 25.12.08-2, 25.12.08_abc123, 25.12.08-2_abc123

              # Extract base version (YY.MM.DD)
              OLD_BASE_VERSION=$(echo "$OLD_TAG" | grep -oE '^[0-9]+\.[0-9]+\.[0-9]+' || echo "")
              NEW_BASE_VERSION=$(echo "$TAG" | grep -oE '^[0-9]+\.[0-9]+\.[0-9]+' || echo "")

              if [ -z "$OLD_BASE_VERSION" ] || [ -z "$NEW_BASE_VERSION" ]; then
                echo "‚ö†Ô∏è  Warning: Could not extract base version for comparison"
                echo "   Old base version: $OLD_BASE_VERSION"
                echo "   New base version: $NEW_BASE_VERSION"
              else
                # Convert to comparable format: YYMMDD
                OLD_VER_NUM=$(echo "$OLD_BASE_VERSION" | tr -d '.')
                NEW_VER_NUM=$(echo "$NEW_BASE_VERSION" | tr -d '.')

                if [ "$NEW_VER_NUM" -lt "$OLD_VER_NUM" ]; then
                  echo "‚ùå Downgrade detected"
                  echo "   Old version: $OLD_BASE_VERSION"
                  echo "   New version: $NEW_BASE_VERSION"
                  echo "   REASON: Downgrades are not permitted (new version must be >= old version)"
                  VALIDATION_FAILED=true
                  FAILED_IMAGES+=("$image: Downgrade from $OLD_BASE_VERSION to $NEW_BASE_VERSION")
                  continue
                elif [ "$NEW_VER_NUM" -eq "$OLD_VER_NUM" ]; then
                  # Same base version - extract and compare rebuild numbers
                  OLD_REBUILD=$(echo "$OLD_TAG" | grep -oE '\-[0-9]+' | tr -d '-' || echo "0")
                  NEW_REBUILD=$(echo "$TAG" | grep -oE '\-[0-9]+' | tr -d '-' || echo "0")

                  # Default to 0 if no rebuild number
                  OLD_REBUILD=${OLD_REBUILD:-0}
                  NEW_REBUILD=${NEW_REBUILD:-0}

                  if [ "$NEW_REBUILD" -lt "$OLD_REBUILD" ]; then
                    echo "‚ùå Rebuild downgrade detected"
                    echo "   Old version: $OLD_BASE_VERSION-$OLD_REBUILD"
                    echo "   New version: $NEW_BASE_VERSION-$NEW_REBUILD"
                    echo "   REASON: Cannot downgrade from rebuild $OLD_REBUILD to rebuild $NEW_REBUILD"
                    VALIDATION_FAILED=true
                    FAILED_IMAGES+=("$image: Rebuild downgrade from -$OLD_REBUILD to -$NEW_REBUILD")
                    continue
                  elif [ "$NEW_REBUILD" -eq "$OLD_REBUILD" ]; then
                    # Same version and rebuild - check for hash changes
                    OLD_HASH=$(echo "$OLD_TAG" | grep -oE '_[a-f0-9]+$' | tr -d '_' || echo "")
                    NEW_HASH=$(echo "$TAG" | grep -oE '_[a-f0-9]+$' | tr -d '_' || echo "")

                    if [ -n "$OLD_HASH" ] && [ -n "$NEW_HASH" ]; then
                      if [ "$OLD_HASH" = "$NEW_HASH" ]; then
                        echo "‚úÖ Same version (no changes): $OLD_TAG = $TAG"
                      else
                        echo "‚úÖ Same version with different hash: $OLD_TAG ‚Üí $TAG"
                        echo "   Old hash: $OLD_HASH"
                        echo "   New hash: $NEW_HASH"
                      fi
                    else
                      echo "‚úÖ Same version: $OLD_BASE_VERSION"
                    fi
                  else
                    echo "‚úÖ Rebuild upgrade: $OLD_BASE_VERSION-$OLD_REBUILD ‚Üí $NEW_BASE_VERSION-$NEW_REBUILD"
                  fi
                else
                  echo "‚úÖ Version upgrade: $OLD_BASE_VERSION ‚Üí $NEW_BASE_VERSION"
                fi
              fi
            else
              echo "‚ÑπÔ∏è  No old image found for comparison (new deployment or first validation)"
            fi

            # 7. Verify image exists in Docker Hub (canonical registry)
            if [ "$VERIFY_EXISTENCE" = "true" ]; then
              # Use canonical image (without registry prefix) to verify in Docker Hub
              CANONICAL_IMAGE="${BASE_REPO}:${TAG}"

              echo ""
              echo "Verifying image exists in registry..."
              echo "   Canonical image: $CANONICAL_IMAGE"

              # Try Docker Hub first
              if docker manifest inspect "$CANONICAL_IMAGE" >/dev/null 2>&1; then
                echo "‚úÖ Image exists in Docker Hub"
                if [ "$REPO" != "$BASE_REPO" ]; then
                  echo "   Note: Assuming mirror registry ($REPO) has the same image"
                fi
              else
                # If not in Docker Hub, try the full image path (for private registries)
                echo "‚ö†Ô∏è  Image not found in Docker Hub, trying full image path: $image"
                if docker manifest inspect "$image" >/dev/null 2>&1; then
                  echo "‚úÖ Image exists in registry: $REPO"
                else
                  echo "‚ùå Registry existence validation failed"
                  echo "   Canonical image: $CANONICAL_IMAGE"
                  echo "   Full image: $image"
                  echo "   REASON: Image does not exist in Docker Hub or specified registry"
                  VALIDATION_FAILED=true
                  FAILED_IMAGES+=("$image: Does not exist in registry")
                  continue
                fi
              fi
            fi

            echo "‚úÖ Image validated successfully: $image"
            echo ""
          done

          # Final result
          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo ""
            echo "‚ùå Validation failed for ${#FAILED_IMAGES[@]} image(s):"
            printf '   - %s\n' "${FAILED_IMAGES[@]}"
            echo "result=fail" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "‚úÖ All images validated successfully"
            echo "result=pass" >> "$GITHUB_OUTPUT"
          fi

  finalize:
    name: Final Status
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-changed-files, validate-image-only-changed, validate-images]
    if: always()
    steps:
      - name: Check all validations
        run: |
          SHOULD_BYPASS="${{ needs.check-org-membership.outputs.should-bypass }}"
          PR_AUTHOR="${{ needs.check-org-membership.outputs.pr-author }}"
          ORGANIZATION="${{ needs.check-org-membership.outputs.organization }}"

          echo "=================================================="
          echo "Deployment Guard - Validation Summary"
          echo "=================================================="

          # Check if bypass is active (based on organization membership)
          if [ "$SHOULD_BYPASS" = "true" ]; then
            echo "‚úÖ VALIDATION BYPASSED"
            echo ""
            echo "PR Author: $PR_AUTHOR"
            echo "Trusted User: YES (${ORGANIZATION} organization member)"
            echo "Organization: $ORGANIZATION"
            echo ""
            echo "üöÄ This PR author is a public member of the trusted organization."
            echo "   All validations have been bypassed."
            echo "   Changes are approved based on organization membership."
            echo ""
            echo "=================================================="
            exit 0
          fi

          # If not bypassed, check validation results
          echo "PR Author: $PR_AUTHOR"
          echo "Trusted User: NO"
          echo "Status: Running full validation"
          echo ""

          FILES_CHECK="${{ needs.validate-changed-files.outputs.allowed-files-check }}"
          IMAGE_ONLY_CHECK="${{ needs.validate-image-only-changed.outputs.image-only-check }}"
          IMAGE_VALIDATION="${{ needs.validate-images.outputs.image-validation }}"

          ENABLE_FILE_ALLOWLIST="${{ inputs.enable_file_allowlist }}"
          ENABLE_IMAGE_ONLY="${{ inputs.enable_image_only_check }}"
          ENABLE_IMAGE_VALIDATION="${{ inputs.enable_image_validation }}"

          echo "Enabled checks:"
          echo "  - File allowlist: $ENABLE_FILE_ALLOWLIST"
          echo "  - Image-only changes: $ENABLE_IMAGE_ONLY"
          echo "  - Image validation: $ENABLE_IMAGE_VALIDATION"
          echo ""
          echo "Results:"
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ]; then
            echo "  - Files allowlist check: ${FILES_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_ONLY" = "true" ]; then
            echo "  - Image-only change check: ${IMAGE_ONLY_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ]; then
            echo "  - Image validation: ${IMAGE_VALIDATION:-skipped}"
          fi
          echo "=================================================="

          # Check file allowlist (if enabled)
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ] && [ "$FILES_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: File allowlist validation failed"
            echo ""
            echo "REASON: One or more modified files are not in the allowlist"
            echo ""
            echo "Validation Rule: Only files matching the following pattern can be modified:"
            echo "  - Pattern: ${{ inputs.allowed_files_pattern }}"
            echo ""
            exit 1
          fi

          # Check image-only changes (if enabled)
          if [ "$ENABLE_IMAGE_ONLY" = "true" ] && [ "$IMAGE_ONLY_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Image-only validation failed"
            echo ""
            echo "REASON: Changes detected beyond the container image field"
            echo ""
            echo "Validation Rule: Only the container image attribute can be modified"
            echo "  - Allowed: Changes to container image field only"
            echo "  - Not allowed: resources, env vars, volumes, replicas, or any other configuration changes"
            echo ""
            exit 1
          fi

          # Check image validation (if enabled)
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ] && [ "$IMAGE_VALIDATION" != "pass" ]; then
            echo "‚ùå BLOCKED: Image validation failed"
            echo ""
            echo "REASON: The specified image does not meet one or more validation requirements"
            echo ""
            echo "Validation Rules:"
            if [ -n "${{ inputs.allowed_image_repositories }}" ]; then
              echo "  - Repository: Only images from '${{ inputs.allowed_image_repositories }}' are allowed"
            fi
            echo "  - Version format: Must match pattern '${{ inputs.allowed_version_pattern }}'"
            if [ "${{ inputs.verify_image_existence }}" = "true" ]; then
              echo "  - Registry existence: Image must exist in the Docker registry"
            fi
            echo "  - No downgrades: Version must be equal to or newer than the current deployed version"
            echo ""
            exit 1
          fi

          echo "‚úÖ All enabled validations passed!"

          # Show validated images if available
          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          if [ -n "$NEW_IMAGES" ] && [ "$NEW_IMAGES" != "[]" ]; then
            echo ""
            echo "The following images were validated and approved:"
            echo "$NEW_IMAGES" | jq -r '.[]' 2>/dev/null | while IFS= read -r img; do
              echo "  ‚úÖ $img"
            done
          fi

      - name: Create PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const shouldBypass = '${{ needs.check-org-membership.outputs.should-bypass }}' === 'true';
            const isOrgMember = '${{ needs.check-org-membership.outputs.is-org-member }}' === 'true';
            const prAuthor = '${{ needs.check-org-membership.outputs.pr-author }}';
            const organization = '${{ needs.check-org-membership.outputs.organization }}';
            const trustedOrg = '${{ inputs.trusted_organization }}';

            let commentBody = '## üõ°Ô∏è Deployment Guard Validation\n\n';

            // Organization membership-based bypass status
            commentBody += '### üë§ Author Verification\n';
            if (shouldBypass && isOrgMember) {
              commentBody += `‚úÖ **TRUSTED USER** - @${prAuthor}\n\n`;
              commentBody += `- Organization: \`${organization}\`\n`;
              commentBody += `- Member Type: Public organization member\n`;
              commentBody += `- Status: üöÄ **All validations bypassed**\n`;
              commentBody += `- Reason: Members of ${organization} organization are fully trusted\n\n`;
              commentBody += '> **Note:** Bypass is granted to PUBLIC members of the organization. ';
              commentBody += `If you're a member but didn't get bypass, ensure your membership is public at https://github.com/orgs/${trustedOrg}/people\n`;
            } else {
              commentBody += `‚ÑπÔ∏è  **STANDARD USER** - @${prAuthor}\n\n`;
              commentBody += `- Status: üîí **Full validation enforced**\n`;
              commentBody += `- Reason: Not a public member of ${trustedOrg} organization\n`;
              commentBody += `- All deployment rules must be satisfied\n\n`;
              if (trustedOrg) {
                commentBody += `> **Note:** To bypass validations, you must be a PUBLIC member of the ${trustedOrg} organization. `;
                commentBody += `Visit https://github.com/orgs/${trustedOrg}/people to check your membership status.\n\n`;
              }

              const filesCheck = '${{ needs.validate-changed-files.outputs.allowed-files-check }}';
              const imageOnlyCheck = '${{ needs.validate-image-only-changed.outputs.image-only-check }}';
              const imageValidation = '${{ needs.validate-images.outputs.image-validation }}';
              const newImages = JSON.parse('${{ needs.validate-image-only-changed.outputs.new-images }}' || '[]');

              // Files check
              commentBody += '### üìÅ File Allowlist Check\n';
              if (filesCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - All modified files are in the allowlist\n\n';
              } else if (filesCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Some files are not in the allowlist\n\n';
                commentBody += `Only files matching \`${{ inputs.allowed_files_pattern }}\` can be modified.\n\n`;
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - File allowlist check not enabled\n\n';
              }

              // Image-only check
              commentBody += '### üîÑ Image-Only Change Check\n';
              if (imageOnlyCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - Only image field was modified\n\n';
              } else if (imageOnlyCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Changes detected beyond image field\n\n';
                commentBody += 'Only the dotCMS container image can be modified. No other fields are allowed.\n\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image-only check not enabled\n\n';
              }

              // Image validation
              commentBody += '### üê≥ Image Validation\n';
              if (imageValidation === 'pass') {
                commentBody += '‚úÖ **PASSED** - All images validated successfully\n\n';
                if (newImages.length > 0) {
                  commentBody += '**Validated images:**\n';
                  newImages.forEach(img => {
                    commentBody += `- \`${img}\`\n`;
                  });
                }
              } else if (imageValidation === 'fail') {
                commentBody += '‚ùå **FAILED** - Image validation failed\n\n';
                commentBody += `**Requirements:**\n`;
                if ('${{ inputs.allowed_image_repositories }}') {
                  commentBody += `- Repository must be: \`${{ inputs.allowed_image_repositories }}\`\n`;
                }
                commentBody += `- Tag must match pattern: \`${{ inputs.allowed_version_pattern }}\`\n`;
                if ('${{ inputs.verify_image_existence }}' === 'true') {
                  commentBody += `- Image must exist in the registry\n`;
                }
                commentBody += '\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image validation not enabled\n\n';
              }

              // Final status
              commentBody += '\n---\n\n';
              if (filesCheck === 'pass' && imageOnlyCheck === 'pass' && imageValidation === 'pass') {
                commentBody += '### ‚úÖ All validations passed!\n\n';
                commentBody += 'This PR meets all deployment requirements.\n';
              } else {
                commentBody += '### ‚ùå Validation failed\n\n';
                commentBody += 'Please address the issues above and push new commits to re-trigger validation.\n';
              }
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
