---
name: Deployment Guard

on:
  workflow_call:
    inputs:
      # Organization-based bypass configuration
      trusted_organization:
        description: 'GitHub organization name whose PUBLIC members can bypass all validations (e.g., dotCMS)'
        required: false
        type: string
        default: ''

      # Validation toggles - enable/disable specific checks
      enable_file_allowlist:
        description: 'Enable file allowlist validation'
        required: false
        type: boolean
        default: true
      enable_image_only_check:
        description: 'Enable image-only change validation (blocks if other fields changed)'
        required: false
        type: boolean
        default: true
      enable_image_validation:
        description: 'Enable image repository, format, and version validation'
        required: false
        type: boolean
        default: true

      # File allowlist configuration
      allowed_files_pattern:
        description: 'Glob pattern for allowed files (e.g., kubernetes/dotcms/**/statefulset.yaml)'
        required: false
        type: string
        default: '**/*'

      # Image validation configuration
      allowed_image_repositories:
        description: 'Comma-separated list of allowed image repositories (e.g., dotcms/dotcms)'
        required: false
        type: string
        default: ''
      allowed_version_pattern:
        description: 'Regex pattern for allowed version tags (default: any)'
        required: false
        type: string
        default: '.*'
      verify_image_existence:
        description: 'Whether to verify image exists in registry'
        required: false
        type: boolean
        default: false

      # Testing parameter
      testing_force_non_bypass:
        description: 'TESTING ONLY: Force non-bypass mode to test validation logic (ignores organization membership)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write

jobs:
  check-org-membership:
    name: Check Organization Membership
    runs-on: ubuntu-latest
    outputs:
      is-org-member: ${{ steps.check.outputs.is_member }}
      pr-author: ${{ steps.check.outputs.author }}
      should-bypass: ${{ steps.check.outputs.should_bypass }}
      organization: ${{ steps.check.outputs.organization }}
    steps:
      - name: Check if PR author is organization member
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const trustedOrg = '${{ inputs.trusted_organization }}';
            const actor = context.payload.pull_request.user.login;

            core.setOutput('author', actor);

            // If no organization configured, don't bypass
            if (!trustedOrg || trustedOrg.trim() === '') {
              console.log('‚ÑπÔ∏è  No trusted organization configured, running full validation');
              core.setOutput('is_member', false);
              core.setOutput('should_bypass', false);
              core.setOutput('organization', '');
              return;
            }

            console.log('');
            console.log('üîç Checking organization membership...');
            console.log(`   Organization: ${trustedOrg}`);
            console.log(`   User: ${actor}`);
            console.log('');

            let isTrusted = false;

            // TESTING MODE: Force non-bypass if testing parameter is enabled
            const testingForceNonBypass = '${{ inputs.testing_force_non_bypass }}' === 'true';

            if (testingForceNonBypass) {
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  TESTING MODE ENABLED');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  Forcing NON-BYPASS mode to test validation logic');
              console.log('‚ö†Ô∏è  Organization membership is being IGNORED for testing');
              console.log('‚ö†Ô∏è  This user will go through full validation');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('');

              isTrusted = false;
              core.setOutput('organization', 'testing-mode');
            } else {
              try {
                // Check if user is a PUBLIC member of the organization
                await github.rest.orgs.checkPublicMembershipForUser({
                  org: trustedOrg,
                  username: actor
                });

                console.log(`‚úÖ User ${actor} is a PUBLIC member of ${trustedOrg}`);
                console.log('üöÄ All validations will be BYPASSED');
                isTrusted = true;
                core.setOutput('organization', trustedOrg);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`‚ùå User ${actor} is NOT a public member of ${trustedOrg}`);
                  console.log('');
                  console.log('üìã TROUBLESHOOTING:');
                  console.log('   If you are a member of the organization:');
                  console.log(`   1. Visit https://github.com/orgs/${trustedOrg}/people`);
                  console.log('   2. Find your username in the list');
                  console.log('   3. Ensure your membership visibility is set to PUBLIC');
                  console.log('   4. Click "Make public" if your membership is currently private');
                  console.log('');
                  console.log('   If you are not listed, contact an organization owner to be added.');
                  console.log('');
                  console.log('üîí Full validation will be enforced');
                } else {
                  console.log(`‚ö†Ô∏è  Error checking organization membership: ${error.message}`);
                  console.log('‚ÑπÔ∏è  Treating as non-member, full validation will be enforced');
                }
                isTrusted = false;
                core.setOutput('organization', '');
              }
            }

            // Set outputs
            core.setOutput('is_member', isTrusted);
            core.setOutput('should_bypass', isTrusted);

            // Final result
            console.log('');
            if (isTrusted) {
              console.log(`‚úÖ RESULT: User ${actor} is a trusted ${trustedOrg} organization member`);
              console.log('üöÄ ALL VALIDATIONS WILL BE BYPASSED');
            } else {
              console.log(`‚ÑπÔ∏è  RESULT: User ${actor} is not a public member of ${trustedOrg}`);
              console.log('üîí FULL VALIDATION WILL BE ENFORCED');
            }
  validate-changed-files:
    name: Validate Changed Files
    runs-on: ubuntu-latest
    needs: check-org-membership
    if: |
      inputs.enable_file_allowlist &&
      needs.check-org-membership.outputs.should-bypass == 'false'
    outputs:
      allowed-files-check: ${{ steps.check-files.outputs.result }}
      changed-files: ${{ steps.get-files.outputs.files }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: get-files
        run: |
          # Get list of changed files in the PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # For push events, use event.before and event.after for correct commit range
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.event.after }}"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '\.ya?ml$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No YAML files changed"
            echo "files=[]" >> "$GITHUB_OUTPUT"
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert to JSON array for output
            FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "files=$FILES_JSON" >> "$GITHUB_OUTPUT"
          fi

      - name: Check files against allowlist
        id: check-files
        run: |
          # Clean temp files from any previous runs
          rm -f /tmp/disallowed_files.txt

          CHANGED_FILES='${{ steps.get-files.outputs.files }}'
          ALLOWED_PATTERN='${{ inputs.allowed_files_pattern }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Validating files against pattern: $ALLOWED_PATTERN"

          # Convert glob pattern to regex
          # First handle special case: .ya?ml ‚Üí \.(yaml|yml)
          # Then replace **/ with placeholder (as a unit, including the slash)
          # Then replace remaining * with [^/]* (match any character except /)
          # Then replace placeholder with ([^/]+/)* (match zero or more path segments)
          # Note: Using # as delimiter to avoid conflicts with |
          # Note: In grep -E, | should NOT be escaped (it's a regex alternation operator)
          PATTERN_REGEX=$(echo "$ALLOWED_PATTERN" | sed 's#\.ya?ml#\\.(yaml|yml)#g' | sed 's#\*\*/#__DOUBLESTAR__#g' | sed 's#\*#[^/]*#g' | sed 's#__DOUBLESTAR__#([^/]+/)*#g')

          echo "$CHANGED_FILES" | jq -r '.[]' | while IFS= read -r file; do
            if ! echo "$file" | grep -qE "^${PATTERN_REGEX}$"; then
              echo "‚ùå File not allowed: $file"
              echo "$file" >> /tmp/disallowed_files.txt
            else
              echo "‚úÖ File allowed: $file"
            fi
          done

          if [ -f /tmp/disallowed_files.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "‚ùå Some files are not in the allowlist"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files are in the allowlist"
          fi

  validate-image-only-changed:
    name: Validate Only Image Changed
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-changed-files]
    if: |
      always() &&
      inputs.enable_image_only_check &&
      needs.check-org-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_file_allowlist == false || needs.validate-changed-files.outputs.allowed-files-check == 'pass')
    outputs:
      image-only-check: ${{ steps.check-changes.outputs.result }}
      new-images: ${{ steps.check-changes.outputs.images }}
      old-images: ${{ steps.check-changes.outputs.old-images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check only image field changed
        id: check-changes
        run: |
          # Clean temp files from any previous runs
          rm -f /tmp/validation_failed.txt /tmp/new_images.txt /tmp/old_images.txt

          CHANGED_FILES='${{ needs.validate-changed-files.outputs.changed-files }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            {
              echo "result=pass"
              echo "images=[]"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_SHA="${{ github.event.pull_request.base.sha }}"

          # Use process substitution to avoid subshell issues with pipe
          while IFS= read -r file; do
            echo "=================================================="
            echo "Validating: $file"
            echo "=================================================="

            # Get old and new YAML content
            OLD_YAML=$(git show "$BASE_SHA:$file" 2>/dev/null || echo "")
            NEW_YAML=$(cat "$file")

            if [ -z "$OLD_YAML" ]; then
              echo "‚ö†Ô∏è  File is new, skipping comparison"
              continue
            fi

            # Extract the main dotCMS container image
            OLD_IMAGE=$(echo "$OLD_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")
            NEW_IMAGE=$(echo "$NEW_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")

            if [ -z "$OLD_IMAGE" ] || [ -z "$NEW_IMAGE" ]; then
              echo "‚ùå Could not extract dotCMS container image"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi

            echo "Old image: $OLD_IMAGE"
            echo "New image: $NEW_IMAGE"

            # Normalize both YAMLs by replacing the dotCMS image with placeholder
            OLD_NORMALIZED=$(echo "$OLD_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')
            NEW_NORMALIZED=$(echo "$NEW_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')

            # Compare normalized YAMLs
            if [ "$OLD_NORMALIZED" != "$NEW_NORMALIZED" ]; then
              echo "‚ùå Changes detected beyond image field in: $file"
              echo ""
              echo "Diff of normalized files:"
              diff <(echo "$OLD_NORMALIZED") <(echo "$NEW_NORMALIZED") || true
              echo "false" > /tmp/validation_failed.txt
            else
              echo "‚úÖ Only image changed: $OLD_IMAGE ‚Üí $NEW_IMAGE"
              echo "$NEW_IMAGE" >> /tmp/new_images.txt
              echo "$OLD_IMAGE" >> /tmp/old_images.txt
            fi
            echo ""
          done < <(echo "$CHANGED_FILES" | jq -r '.[]')

          if [ -f /tmp/validation_failed.txt ]; then
            {
              echo "result=fail"
              echo "images=[]"
              echo "old-images=[]"
            } >> "$GITHUB_OUTPUT"
            exit 1
          else
            # Use block redirect to satisfy shellcheck SC2129
            {
              if [ -f /tmp/new_images.txt ]; then
                IMAGES_JSON=$(jq -R -s -c 'split("\n") | map(select(length > 0)) | unique' < /tmp/new_images.txt)
                echo "images=$IMAGES_JSON"
              else
                echo "images=[]"
              fi

              if [ -f /tmp/old_images.txt ]; then
                OLD_IMAGES_JSON=$(jq -R -s -c 'split("\n") | map(select(length > 0)) | unique' < /tmp/old_images.txt)
                echo "old-images=$OLD_IMAGES_JSON"
              else
                echo "old-images=[]"
              fi

              echo "result=pass"
            } >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files have only image field changes"
          fi

  validate-images:
    name: Validate Images
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-image-only-changed]
    if: |
      always() &&
      inputs.enable_image_validation &&
      needs.check-org-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_image_only_check == false || needs.validate-image-only-changed.outputs.image-only-check == 'pass')
    outputs:
      image-validation: ${{ steps.validate.outputs.result }}
    steps:
      - name: Validate image format, repository, tag, and existence
        id: validate
        run: |
          # Clean temp files from any previous runs
          rm -f /tmp/validation_failed.txt

          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          OLD_IMAGES='${{ needs.validate-image-only-changed.outputs.old-images }}'
          ALLOWED_REPOS='${{ inputs.allowed_image_repositories }}'
          VERSION_PATTERN='${{ inputs.allowed_version_pattern }}'
          VERIFY_EXISTENCE='${{ inputs.verify_image_existence }}'

          if [ "$NEW_IMAGES" = "" ] || [ "$NEW_IMAGES" = "[]" ]; then
            echo "No new images to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Create arrays to map new images to old images by index
          # Using mapfile to satisfy shellcheck SC2207
          mapfile -t OLD_IMAGES_ARRAY < <(echo "$OLD_IMAGES" | jq -r '.[]')

          INDEX=0
          # Use process substitution to avoid subshell issues with pipe
          while IFS= read -r image; do
            echo "=================================================="
            echo "Validating image: $image"
            echo "=================================================="

            # 1. Validate format (repo/name:tag)
            if ! [[ "$image" =~ ^[a-zA-Z0-9/_.-]+:[a-zA-Z0-9_.-]+$ ]]; then
              echo "‚ùå Image format validation failed"
              echo "   Image: $image"
              echo "   REASON: Invalid image format (expected format: repository/name:tag)"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Image format is valid"

            # 2. Extract repository and tag
            REPO="${image%:*}"
            TAG="${image##*:}"
            echo "   Full image: $image"
            echo "   Repository: $REPO"
            echo "   Tag: $TAG"

            # 3. Extract base repository name (handle both with and without registry prefix)
            # This is needed for both repository validation and image existence check
            # Examples:
            #   mirror.gcr.io/dotcms/dotcms -> dotcms/dotcms
            #   gcr.io/project/dotcms/dotcms -> dotcms/dotcms
            #   dotcms/dotcms -> dotcms/dotcms
            BASE_REPO="$REPO"
            if [[ "$REPO" =~ / ]]; then
              # Check if REPO starts with a registry domain
              if [[ "$REPO" =~ ^[a-z0-9.-]+\.[a-z]{2,}/ ]] || [[ "$REPO" =~ ^gcr\.io/ ]] || [[ "$REPO" =~ ^.*\.gcr\.io/ ]]; then
                # Extract everything after the first slash (removes registry domain)
                BASE_REPO="${REPO#*/}"
              fi
            fi
            echo "   Base repository: $BASE_REPO"

            # 4. Check repository is in allowlist (if configured)
            if [ -n "$ALLOWED_REPOS" ]; then
              REPO_ALLOWED=false
              IFS=',' read -ra ALLOWED <<< "$ALLOWED_REPOS"
              for allowed_repo in "${ALLOWED[@]}"; do
                # Trim whitespace
                allowed_repo=$(echo "$allowed_repo" | xargs)

                echo "   Comparing '$BASE_REPO' with allowed '$allowed_repo'"
                if [[ "$BASE_REPO" == "$allowed_repo" ]] || [[ "$REPO" == "$allowed_repo" ]]; then
                  REPO_ALLOWED=true
                  echo "   ‚úì Match found"
                  break
                fi
              done

              if [ "$REPO_ALLOWED" = false ]; then
                echo "‚ùå Repository validation failed"
                echo "   Repository: $REPO"
                echo "   REASON: Repository is not in the allowlist"
                echo "   Allowed repositories: $ALLOWED_REPOS"
                echo "false" > /tmp/validation_failed.txt
                continue
              fi
              echo "‚úÖ Repository is allowed"
            else
              echo "‚ÑπÔ∏è  Repository validation skipped (no allowlist configured)"
            fi

            # 5. Validate tag matches version pattern
            if ! [[ "$TAG" =~ $VERSION_PATTERN ]]; then
              echo "‚ùå Version pattern validation failed"
              echo "   Tag: $TAG"
              echo "   Required pattern: $VERSION_PATTERN"
              echo "   REASON: Only evergreen date-based versions are allowed"
              echo "   Accepted formats: YY.MM.DD, YY.MM.DD-N, YY.MM.DD_hash, YY.MM.DD-N_hash (where YY >= 25)"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Tag matches version pattern"

            # 6. Anti-downgrade validation (compare versions)
            # Get the corresponding old image by index
            OLD_IMAGE="${OLD_IMAGES_ARRAY[$INDEX]}"
            if [ -n "$OLD_IMAGE" ]; then
              # Extract old tag
              OLD_TAG="${OLD_IMAGE##*:}"
              echo ""
              echo "Checking for downgrades..."
              echo "   Old tag: $OLD_TAG"
              echo "   New tag: $TAG"

              # Extract base version for comparison
              # Handle formats: YY.MM.DD, YY.MM.DD-N, YY.MM.DD_hash, YY.MM.DD-N_hash
              # First remove hash (everything after underscore)
              OLD_VERSION_NO_HASH="${OLD_TAG%%_*}"
              NEW_VERSION_NO_HASH="${TAG%%_*}"

              # Then remove rebuild number (everything after first dash)
              OLD_VERSION="${OLD_VERSION_NO_HASH%%-*}"
              NEW_VERSION="${NEW_VERSION_NO_HASH%%-*}"

              # Compare versions (YY.MM.DD format)
              # Convert to comparable format: YYMMDD
              OLD_VER_NUM=$(echo "$OLD_VERSION" | tr -d '.')
              NEW_VER_NUM=$(echo "$NEW_VERSION" | tr -d '.')

              if [ "$NEW_VER_NUM" -lt "$OLD_VER_NUM" ]; then
                echo "‚ùå Downgrade detected"
                echo "   Old version: $OLD_VERSION"
                echo "   New version: $NEW_VERSION"
                echo "   REASON: Downgrades are not permitted (new version must be >= old version)"
                echo "false" > /tmp/validation_failed.txt
                continue
              elif [ "$NEW_VER_NUM" -eq "$OLD_VER_NUM" ]; then
                echo "‚úÖ Same version (suffix may differ): $OLD_VERSION ‚Üí $NEW_VERSION"
              else
                echo "‚úÖ Version upgrade: $OLD_VERSION ‚Üí $NEW_VERSION"
              fi
            else
              echo "‚ÑπÔ∏è  No old image found for comparison (new deployment or first validation)"
            fi

            # Increment index for next iteration
            ((INDEX++))

            # 7. Verify image exists in Docker Hub (canonical registry)
            if [ "$VERIFY_EXISTENCE" = "true" ]; then
              # Use canonical image (without registry prefix) to verify in Docker Hub
              # This assumes mirror registries have the same images as Docker Hub
              CANONICAL_IMAGE="${BASE_REPO}:${TAG}"

              echo "Verifying image exists in Docker Hub (canonical)..."
              echo "   Canonical image: $CANONICAL_IMAGE"

              if docker manifest inspect "$CANONICAL_IMAGE" >/dev/null 2>&1; then
                echo "‚úÖ Image exists in Docker Hub"
                if [ "$REPO" != "$BASE_REPO" ]; then
                  echo "   Note: Assuming mirror registry ($REPO) has the same image"
                fi
              else
                echo "‚ùå Registry existence validation failed"
                echo "   Canonical image: $CANONICAL_IMAGE"
                echo "   REASON: Image does not exist in Docker Hub"
                echo "false" > /tmp/validation_failed.txt
                continue
              fi
            fi

            echo "‚úÖ Image validated successfully: $image"
            echo ""
          done < <(echo "$NEW_IMAGES" | jq -r '.[]')

          if [ -f /tmp/validation_failed.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All images validated successfully"
          fi

  finalize:
    name: Final Status
    runs-on: ubuntu-latest
    needs: [check-org-membership, validate-changed-files, validate-image-only-changed, validate-images]
    if: always()
    steps:
      - name: Check all validations
        run: |
          SHOULD_BYPASS="${{ needs.check-org-membership.outputs.should-bypass }}"
          PR_AUTHOR="${{ needs.check-org-membership.outputs.pr-author }}"
          ORGANIZATION="${{ needs.check-org-membership.outputs.organization }}"

          echo "=================================================="
          echo "Deployment Guard - Validation Summary"
          echo "=================================================="

          # Check if bypass is active (based on organization membership)
          if [ "$SHOULD_BYPASS" = "true" ]; then
            echo "‚úÖ VALIDATION BYPASSED"
            echo ""
            echo "PR Author: $PR_AUTHOR"
            echo "Trusted User: YES (${ORGANIZATION} organization member)"
            echo "Organization: $ORGANIZATION"
            echo ""
            echo "üöÄ This PR author is a public member of the trusted organization."
            echo "   All validations have been bypassed."
            echo "   Changes are approved based on organization membership."
            echo ""
            echo "=================================================="
            exit 0
          fi

          # If not bypassed, check validation results
          echo "PR Author: $PR_AUTHOR"
          echo "Trusted User: NO"
          echo "Status: Running full validation"
          echo ""

          FILES_CHECK="${{ needs.validate-changed-files.outputs.allowed-files-check }}"
          IMAGE_ONLY_CHECK="${{ needs.validate-image-only-changed.outputs.image-only-check }}"
          IMAGE_VALIDATION="${{ needs.validate-images.outputs.image-validation }}"

          ENABLE_FILE_ALLOWLIST="${{ inputs.enable_file_allowlist }}"
          ENABLE_IMAGE_ONLY="${{ inputs.enable_image_only_check }}"
          ENABLE_IMAGE_VALIDATION="${{ inputs.enable_image_validation }}"

          echo "Enabled checks:"
          echo "  - File allowlist: $ENABLE_FILE_ALLOWLIST"
          echo "  - Image-only changes: $ENABLE_IMAGE_ONLY"
          echo "  - Image validation: $ENABLE_IMAGE_VALIDATION"
          echo ""
          echo "Results:"
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ]; then
            echo "  - Files allowlist check: ${FILES_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_ONLY" = "true" ]; then
            echo "  - Image-only change check: ${IMAGE_ONLY_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ]; then
            echo "  - Image validation: ${IMAGE_VALIDATION:-skipped}"
          fi
          echo "=================================================="

          # Check file allowlist (if enabled)
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ] && [ "$FILES_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: File allowlist validation failed"
            echo ""
            echo "REASON: One or more modified files are not in the allowlist"
            echo ""
            echo "Validation Rule: Only files matching the following pattern can be modified:"
            echo "  - Pattern: ${{ inputs.allowed_files_pattern }}"
            echo ""
            exit 1
          fi

          # Check image-only changes (if enabled)
          if [ "$ENABLE_IMAGE_ONLY" = "true" ] && [ "$IMAGE_ONLY_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Image-only validation failed"
            echo ""
            echo "REASON: Changes detected beyond the container image field"
            echo ""
            echo "Validation Rule: Only the container image attribute can be modified"
            echo "  - Allowed: Changes to container image field only"
            echo "  - Not allowed: resources, env vars, volumes, replicas, or any other configuration changes"
            echo ""
            exit 1
          fi

          # Check image validation (if enabled)
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ] && [ "$IMAGE_VALIDATION" != "pass" ]; then
            echo "‚ùå BLOCKED: Image validation failed"
            echo ""
            echo "REASON: The specified image does not meet one or more validation requirements"
            echo ""
            echo "Validation Rules:"
            if [ -n "${{ inputs.allowed_image_repositories }}" ]; then
              echo "  - Repository: Only images from '${{ inputs.allowed_image_repositories }}' are allowed"
            fi
            echo "  - Version format: Must match pattern '${{ inputs.allowed_version_pattern }}'"
            echo "    (Evergreen date-based versions only: YY.MM.DD, YY.MM.DD-N, YY.MM.DD_hash, YY.MM.DD-N_hash where YY >= 25)"
            if [ "${{ inputs.verify_image_existence }}" = "true" ]; then
              echo "  - Registry existence: Image must exist in the Docker registry"
            fi
            echo "  - No downgrades: Version must be equal to or newer than the current deployed version"
            echo ""
            exit 1
          fi

          echo "‚úÖ All enabled validations passed!"

          # Show validated images if available
          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          if [ -n "$NEW_IMAGES" ] && [ "$NEW_IMAGES" != "[]" ]; then
            echo ""
            echo "The following images were validated and approved:"
            echo "$NEW_IMAGES" | jq -r '.[]' 2>/dev/null | while IFS= read -r img; do
              echo "  ‚úÖ $img"
            done
          fi

      - name: Create PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const shouldBypass = '${{ needs.check-org-membership.outputs.should-bypass }}' === 'true';
            const isOrgMember = '${{ needs.check-org-membership.outputs.is-org-member }}' === 'true';
            const prAuthor = '${{ needs.check-org-membership.outputs.pr-author }}';
            const organization = '${{ needs.check-org-membership.outputs.organization }}';
            const trustedOrg = '${{ inputs.trusted_organization }}';

            let commentBody = '## üõ°Ô∏è Deployment Guard Validation\n\n';

            // Organization membership-based bypass status
            commentBody += '### üë§ Author Verification\n';
            if (shouldBypass && isOrgMember) {
              commentBody += `‚úÖ **TRUSTED USER** - @${prAuthor}\n\n`;
              commentBody += `- Organization: \`${organization}\`\n`;
              commentBody += `- Member Type: Public organization member\n`;
              commentBody += `- Status: üöÄ **All validations bypassed**\n`;
              commentBody += `- Reason: Members of ${organization} organization are fully trusted\n\n`;
              commentBody += '> **Note:** Bypass is granted to PUBLIC members of the organization. ';
              commentBody += `If you're a member but didn't get bypass, ensure your membership is public at https://github.com/orgs/${trustedOrg}/people\n`;
            } else {
              commentBody += `‚ÑπÔ∏è  **STANDARD USER** - @${prAuthor}\n\n`;
              commentBody += `- Status: üîí **Full validation enforced**\n`;
              commentBody += `- Reason: Not a public member of ${trustedOrg} organization\n`;
              commentBody += `- All deployment rules must be satisfied\n\n`;
              if (trustedOrg) {
                commentBody += `> **Note:** To bypass validations, you must be a PUBLIC member of the ${trustedOrg} organization. `;
                commentBody += `Visit https://github.com/orgs/${trustedOrg}/people to check your membership status.\n\n`;
              }

              const filesCheck = '${{ needs.validate-changed-files.outputs.allowed-files-check }}';
              const imageOnlyCheck = '${{ needs.validate-image-only-changed.outputs.image-only-check }}';
              const imageValidation = '${{ needs.validate-images.outputs.image-validation }}';
              const newImages = JSON.parse('${{ needs.validate-image-only-changed.outputs.new-images }}' || '[]');

              // Files check
              commentBody += '### üìÅ File Allowlist Check\n';
              if (filesCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - All modified files are in the allowlist\n\n';
              } else if (filesCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Some files are not in the allowlist\n\n';
                commentBody += `Only files matching \`${{ inputs.allowed_files_pattern }}\` can be modified.\n\n`;
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - File allowlist check not enabled\n\n';
              }

              // Image-only check
              commentBody += '### üîÑ Image-Only Change Check\n';
              if (imageOnlyCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - Only image field was modified\n\n';
              } else if (imageOnlyCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Changes detected beyond image field\n\n';
                commentBody += 'Only the dotCMS container image can be modified. No other fields are allowed.\n\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image-only check not enabled\n\n';
              }

              // Image validation
              commentBody += '### üê≥ Image Validation\n';
              if (imageValidation === 'pass') {
                commentBody += '‚úÖ **PASSED** - All images validated successfully\n\n';
                if (newImages.length > 0) {
                  commentBody += '**Validated images:**\n';
                  newImages.forEach(img => {
                    commentBody += `- \`${img}\`\n`;
                  });
                }
              } else if (imageValidation === 'fail') {
                commentBody += '‚ùå **FAILED** - Image validation failed\n\n';
                commentBody += `**Requirements:**\n`;
                if ('${{ inputs.allowed_image_repositories }}') {
                  commentBody += `- Repository must be: \`${{ inputs.allowed_image_repositories }}\`\n`;
                }
                commentBody += `- Tag must match pattern: \`${{ inputs.allowed_version_pattern }}\`\n`;
                if ('${{ inputs.verify_image_existence }}' === 'true') {
                  commentBody += `- Image must exist in the registry\n`;
                }
                commentBody += '\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image validation not enabled\n\n';
              }

              // Final status
              commentBody += '\n---\n\n';
              if (filesCheck === 'pass' && imageOnlyCheck === 'pass' && imageValidation === 'pass') {
                commentBody += '### ‚úÖ All validations passed!\n\n';
                commentBody += 'This PR meets all deployment requirements.\n';
              } else {
                commentBody += '### ‚ùå Validation failed\n\n';
                commentBody += 'Please address the issues above and push new commits to re-trigger validation.\n';
              }
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
