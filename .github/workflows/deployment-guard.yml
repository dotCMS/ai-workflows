---
name: Deployment Guard

on:
  workflow_call:
    inputs:
      # Team-based bypass configuration
      trusted_github_teams:
        description: 'Comma-separated list of GitHub team slugs that can bypass all validations (e.g., platform-engineers,dotSysadmins)'
        required: false
        type: string
        default: ''

      # Validation toggles - enable/disable specific checks
      enable_file_allowlist:
        description: 'Enable file allowlist validation'
        required: false
        type: boolean
        default: true
      enable_image_only_check:
        description: 'Enable image-only change validation (blocks if other fields changed)'
        required: false
        type: boolean
        default: true
      enable_image_validation:
        description: 'Enable image repository, format, and version validation'
        required: false
        type: boolean
        default: true

      # File allowlist configuration
      allowed_files_pattern:
        description: 'Glob pattern for allowed files (e.g., kubernetes/dotcms/**/statefulset.yaml)'
        required: false
        type: string
        default: '**/*'

      # Image validation configuration
      allowed_image_repositories:
        description: 'Comma-separated list of allowed image repositories (e.g., dotcms/dotcms)'
        required: false
        type: string
        default: ''
      allowed_version_pattern:
        description: 'Regex pattern for allowed version tags (default: any)'
        required: false
        type: string
        default: '.*'
      verify_image_existence:
        description: 'Whether to verify image exists in registry'
        required: false
        type: boolean
        default: false

      # Testing parameter
      testing_force_non_bypass:
        description: 'TESTING ONLY: Force non-bypass mode to test validation logic (ignores actual permissions)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write

jobs:
  check-team-membership:
    name: Check Team Membership
    runs-on: ubuntu-latest
    outputs:
      is-team-member: ${{ steps.check.outputs.is_member }}
      pr-author: ${{ steps.check.outputs.author }}
      should-bypass: ${{ steps.check.outputs.should_bypass }}
      matched-team: ${{ steps.check.outputs.matched_team }}
    steps:
      - name: Check if PR author is in trusted teams
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const trustedTeamsInput = '${{ inputs.trusted_github_teams }}';

            // If no teams configured, don't bypass
            if (!trustedTeamsInput) {
              console.log('‚ÑπÔ∏è  No trusted teams configured, running full validation');
              core.setOutput('is_member', false);
              core.setOutput('should_bypass', false);
              core.setOutput('author', context.payload.pull_request.user.login);
              core.setOutput('matched_team', '');
              return;
            }

            const actor = context.payload.pull_request.user.login;
            const org = context.repo.owner;
            const repo = context.repo.repo;

            // Parse comma-separated list of teams
            const trustedTeams = trustedTeamsInput.split(',').map(t => t.trim()).filter(t => t);

            core.setOutput('author', actor);

            console.log(`Checking repository permissions for ${actor}...`);
            console.log(`Trusted teams (for reference): ${trustedTeams.join(', ')}`);
            console.log('');
            console.log('Note: Due to GitHub API limitations, we check repository permission level');
            console.log('instead of direct team membership. Users with admin or maintain permissions');
            console.log('can bypass validations (these permissions typically align with team membership).');
            console.log('');

            // Check user's permission level in the repository
            let isTrusted = false;
            let permissionLevel = 'none';
            let matchedTeam = '';

            // TESTING MODE: Force non-bypass if testing parameter is enabled
            const testingForceNonBypass = '${{ inputs.testing_force_non_bypass }}' === 'true';

            if (testingForceNonBypass) {
              console.log('');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  TESTING MODE ENABLED');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('‚ö†Ô∏è  Forcing NON-BYPASS mode to test validation logic');
              console.log('‚ö†Ô∏è  User permissions are being IGNORED for testing');
              console.log('‚ö†Ô∏è  This user will go through full validation');
              console.log('‚ö†Ô∏è  ============================================');
              console.log('');

              isTrusted = false;
              permissionLevel = 'testing-mode';
              matchedTeam = 'testing-mode';
            } else {
              try {
                console.log(`Checking permission level for ${actor}...`);
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: org,
                  repo: repo,
                  username: actor
                });

                permissionLevel = permission.permission;
                console.log(`  Permission level: ${permissionLevel}`);

                // Users with admin or maintain permissions can bypass
                // These are typically members of platform-engineers, dotSysadmins, etc.
                if (permissionLevel === 'admin' || permissionLevel === 'maintain') {
                  isTrusted = true;
                  matchedTeam = `repo-${permissionLevel}`;
                  console.log(`  ‚úÖ User ${actor} has ${permissionLevel} permission - TRUSTED`);
                } else {
                  console.log(`  ‚ÑπÔ∏è  User ${actor} has ${permissionLevel} permission - NOT TRUSTED`);
                  console.log(`  ‚ÑπÔ∏è  Only 'admin' or 'maintain' permissions grant bypass rights`);
                }
              } catch (error) {
                console.log(`  ‚ö†Ô∏è  Error checking permission: ${error.message}`);
                console.log(`  ‚ÑπÔ∏è  Treating as non-trusted user`);
              }
            }

            // Set outputs
            core.setOutput('is_member', isTrusted);
            core.setOutput('should_bypass', isTrusted);
            core.setOutput('matched_team', matchedTeam);

            // Final result
            console.log('');
            if (isTrusted) {
              console.log(`‚úÖ RESULT: User ${actor} has ${permissionLevel} permission`);
              console.log('üöÄ ALL VALIDATIONS WILL BE BYPASSED - User is trusted based on repository permissions');
            } else {
              console.log(`‚ÑπÔ∏è  RESULT: User ${actor} does not have sufficient permissions`);
              console.log('üîí Full validation will be enforced');
            }
  validate-changed-files:
    name: Validate Changed Files
    runs-on: ubuntu-latest
    needs: check-team-membership
    if: |
      inputs.enable_file_allowlist &&
      needs.check-team-membership.outputs.should-bypass == 'false'
    outputs:
      allowed-files-check: ${{ steps.check-files.outputs.result }}
      changed-files: ${{ steps.get-files.outputs.files }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: get-files
        run: |
          # Get list of changed files in the PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            BASE_SHA="origin/${{ github.event.repository.default_branch }}"
            HEAD_SHA="HEAD"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '\.ya?ml$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No YAML files changed"
            echo "files=" >> "$GITHUB_OUTPUT"
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert to JSON array for output
            FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "files=$FILES_JSON" >> "$GITHUB_OUTPUT"
          fi

      - name: Check files against allowlist
        id: check-files
        run: |
          CHANGED_FILES='${{ steps.get-files.outputs.files }}'
          ALLOWED_PATTERN='${{ inputs.allowed_files_pattern }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Validating files against pattern: $ALLOWED_PATTERN"

          # Convert glob pattern to regex
          # First handle special case: .ya?ml ‚Üí \.(yaml|yml)
          # Then replace **/ with placeholder (as a unit, including the slash)
          # Then replace remaining * with [^/]* (match any character except /)
          # Then replace placeholder with ([^/]+/)* (match zero or more path segments)
          # Note: Using # as delimiter to avoid conflicts with |
          # Note: In grep -E, | should NOT be escaped (it's a regex alternation operator)
          PATTERN_REGEX=$(echo "$ALLOWED_PATTERN" | sed 's#\.ya?ml#\\.(yaml|yml)#g' | sed 's#\*\*/#__DOUBLESTAR__#g' | sed 's#\*#[^/]*#g' | sed 's#__DOUBLESTAR__#([^/]+/)*#g')

          echo "$CHANGED_FILES" | jq -r '.[]' | while IFS= read -r file; do
            if ! echo "$file" | grep -qE "^${PATTERN_REGEX}$"; then
              echo "‚ùå File not allowed: $file"
              echo "$file" >> /tmp/disallowed_files.txt
            else
              echo "‚úÖ File allowed: $file"
            fi
          done

          if [ -f /tmp/disallowed_files.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "‚ùå Some files are not in the allowlist"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files are in the allowlist"
          fi

  validate-image-only-changed:
    name: Validate Only Image Changed
    runs-on: ubuntu-latest
    needs: [check-team-membership, validate-changed-files]
    if: |
      always() &&
      inputs.enable_image_only_check &&
      needs.check-team-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_file_allowlist == false || needs.validate-changed-files.outputs.allowed-files-check == 'pass')
    outputs:
      image-only-check: ${{ steps.check-changes.outputs.result }}
      new-images: ${{ steps.check-changes.outputs.images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check only image field changed
        id: check-changes
        run: |
          CHANGED_FILES='${{ needs.validate-changed-files.outputs.changed-files }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_SHA="${{ github.event.pull_request.base.sha }}"

          echo "$CHANGED_FILES" | jq -r '.[]' | while IFS= read -r file; do
            echo "=================================================="
            echo "Validating: $file"
            echo "=================================================="

            # Get old and new YAML content
            OLD_YAML=$(git show "$BASE_SHA:$file" 2>/dev/null || echo "")
            NEW_YAML=$(cat "$file")

            if [ -z "$OLD_YAML" ]; then
              echo "‚ö†Ô∏è  File is new, skipping comparison"
              continue
            fi

            # Extract the main dotCMS container image
            OLD_IMAGE=$(echo "$OLD_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")
            NEW_IMAGE=$(echo "$NEW_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")

            if [ -z "$OLD_IMAGE" ] || [ -z "$NEW_IMAGE" ]; then
              echo "‚ùå Could not extract dotCMS container image"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi

            echo "Old image: $OLD_IMAGE"
            echo "New image: $NEW_IMAGE"

            # Normalize both YAMLs by replacing the dotCMS image with placeholder
            OLD_NORMALIZED=$(echo "$OLD_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')
            NEW_NORMALIZED=$(echo "$NEW_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')

            # Compare normalized YAMLs
            if [ "$OLD_NORMALIZED" != "$NEW_NORMALIZED" ]; then
              echo "‚ùå Changes detected beyond image field in: $file"
              echo ""
              echo "Diff of normalized files:"
              diff <(echo "$OLD_NORMALIZED") <(echo "$NEW_NORMALIZED") || true
              echo "false" > /tmp/validation_failed.txt
            else
              echo "‚úÖ Only image changed: $OLD_IMAGE ‚Üí $NEW_IMAGE"
              echo "$NEW_IMAGE" >> /tmp/new_images.txt
            fi
            echo ""
          done

          if [ -f /tmp/validation_failed.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            exit 1
          else
            if [ -f /tmp/new_images.txt ]; then
              IMAGES_JSON=$(jq -R -s -c 'split("\n") | map(select(length > 0)) | unique' < /tmp/new_images.txt)
              echo "images=$IMAGES_JSON" >> "$GITHUB_OUTPUT"
            else
              echo "images=[]" >> "$GITHUB_OUTPUT"
            fi
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files have only image field changes"
          fi

  validate-images:
    name: Validate Images
    runs-on: ubuntu-latest
    needs: [check-team-membership, validate-image-only-changed]
    if: |
      always() &&
      inputs.enable_image_validation &&
      needs.check-team-membership.outputs.should-bypass == 'false' &&
      (inputs.enable_image_only_check == false || needs.validate-image-only-changed.outputs.image-only-check == 'pass')
    outputs:
      image-validation: ${{ steps.validate.outputs.result }}
    steps:
      - name: Validate image format, repository, tag, and existence
        id: validate
        run: |
          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          ALLOWED_REPOS='${{ inputs.allowed_image_repositories }}'
          VERSION_PATTERN='${{ inputs.allowed_version_pattern }}'
          VERIFY_EXISTENCE='${{ inputs.verify_image_existence }}'

          if [ "$NEW_IMAGES" = "" ] || [ "$NEW_IMAGES" = "[]" ]; then
            echo "No new images to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "$NEW_IMAGES" | jq -r '.[]' | while IFS= read -r image; do
            echo "=================================================="
            echo "Validating image: $image"
            echo "=================================================="

            # 1. Validate format (repo/name:tag)
            if ! [[ "$image" =~ ^[a-zA-Z0-9_/-]+:[a-zA-Z0-9._-]+$ ]]; then
              echo "‚ùå Invalid image format: $image"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Image format is valid"

            # 2. Extract repository and tag
            REPO="${image%:*}"
            TAG="${image##*:}"
            echo "   Repository: $REPO"
            echo "   Tag: $TAG"

            # 3. Check repository is in allowlist (if configured)
            if [ -n "$ALLOWED_REPOS" ]; then
              REPO_ALLOWED=false
              IFS=',' read -ra ALLOWED <<< "$ALLOWED_REPOS"
              for allowed_repo in "${ALLOWED[@]}"; do
                # Trim whitespace
                allowed_repo=$(echo "$allowed_repo" | xargs)
                if [[ "$REPO" == "$allowed_repo" ]]; then
                  REPO_ALLOWED=true
                  break
                fi
              done

              if [ "$REPO_ALLOWED" = false ]; then
                echo "‚ùå Repository not allowed: $REPO"
                echo "   Allowed repositories: $ALLOWED_REPOS"
                echo "false" > /tmp/validation_failed.txt
                continue
              fi
              echo "‚úÖ Repository is allowed"
            else
              echo "‚ÑπÔ∏è  Repository validation skipped (no allowlist configured)"
            fi

            # 4. Validate tag matches version pattern
            if ! [[ "$TAG" =~ $VERSION_PATTERN ]]; then
              echo "‚ùå Tag does not match version pattern: $TAG"
              echo "   Expected pattern: $VERSION_PATTERN"
              echo "   This typically means: date-based versions YY.MM.DD where YY >= 25"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Tag matches version pattern"

            # 5. Verify image exists in registry (optional)
            if [ "$VERIFY_EXISTENCE" = "true" ]; then
              echo "Verifying image exists in registry..."
              if docker manifest inspect "$image" >/dev/null 2>&1; then
                echo "‚úÖ Image exists in registry"
              else
                echo "‚ùå Image does not exist in registry: $image"
                echo "false" > /tmp/validation_failed.txt
                continue
              fi
            fi

            echo "‚úÖ Image validated successfully: $image"
            echo ""
          done

          if [ -f /tmp/validation_failed.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All images validated successfully"
          fi

  finalize:
    name: Final Status
    runs-on: ubuntu-latest
    needs: [check-team-membership, validate-changed-files, validate-image-only-changed, validate-images]
    if: always()
    steps:
      - name: Check all validations
        run: |
          SHOULD_BYPASS="${{ needs.check-team-membership.outputs.should-bypass }}"
          PR_AUTHOR="${{ needs.check-team-membership.outputs.pr-author }}"
          MATCHED_TEAM="${{ needs.check-team-membership.outputs.matched-team }}"

          echo "=================================================="
          echo "Deployment Guard - Validation Summary"
          echo "=================================================="

          # Check if bypass is active (based on repository permissions)
          if [ "$SHOULD_BYPASS" = "true" ]; then
            echo "‚úÖ VALIDATION BYPASSED"
            echo ""
            echo "PR Author: $PR_AUTHOR"
            echo "Trusted User: YES"
            echo "Permission Level: $MATCHED_TEAM"
            echo ""
            echo "üöÄ This PR author has elevated repository permissions."
            echo "   All validations have been bypassed."
            echo "   Changes are approved based on trust in admins/maintainers."
            echo ""
            echo "=================================================="
            exit 0
          fi

          # If not bypassed, check validation results
          echo "PR Author: $PR_AUTHOR"
          echo "Trusted User: NO"
          echo "Status: Running full validation"
          echo ""

          FILES_CHECK="${{ needs.validate-changed-files.outputs.allowed-files-check }}"
          IMAGE_ONLY_CHECK="${{ needs.validate-image-only-changed.outputs.image-only-check }}"
          IMAGE_VALIDATION="${{ needs.validate-images.outputs.image-validation }}"

          ENABLE_FILE_ALLOWLIST="${{ inputs.enable_file_allowlist }}"
          ENABLE_IMAGE_ONLY="${{ inputs.enable_image_only_check }}"
          ENABLE_IMAGE_VALIDATION="${{ inputs.enable_image_validation }}"

          echo "Enabled checks:"
          echo "  - File allowlist: $ENABLE_FILE_ALLOWLIST"
          echo "  - Image-only changes: $ENABLE_IMAGE_ONLY"
          echo "  - Image validation: $ENABLE_IMAGE_VALIDATION"
          echo ""
          echo "Results:"
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ]; then
            echo "  - Files allowlist check: ${FILES_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_ONLY" = "true" ]; then
            echo "  - Image-only change check: ${IMAGE_ONLY_CHECK:-skipped}"
          fi
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ]; then
            echo "  - Image validation: ${IMAGE_VALIDATION:-skipped}"
          fi
          echo "=================================================="

          # Check file allowlist (if enabled)
          if [ "$ENABLE_FILE_ALLOWLIST" = "true" ] && [ "$FILES_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Modified files are not in the allowlist"
            echo ""
            echo "Only the following files can be modified:"
            echo "  - ${{ inputs.allowed_files_pattern }}"
            echo ""
            echo "Please ensure you're only modifying allowed files."
            exit 1
          fi

          # Check image-only changes (if enabled)
          if [ "$ENABLE_IMAGE_ONLY" = "true" ] && [ "$IMAGE_ONLY_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Changes detected beyond the image field"
            echo ""
            echo "Only the container image field can be modified."
            echo "No other changes are allowed (resources, env vars, volumes, etc.)"
            echo ""
            echo "Please revert any non-image changes and try again."
            exit 1
          fi

          # Check image validation (if enabled)
          if [ "$ENABLE_IMAGE_VALIDATION" = "true" ] && [ "$IMAGE_VALIDATION" != "pass" ]; then
            echo "‚ùå BLOCKED: Image validation failed"
            echo ""
            echo "Image validation requirements:"
            if [ -n "${{ inputs.allowed_image_repositories }}" ]; then
              echo "  - Repository must be: ${{ inputs.allowed_image_repositories }}"
            fi
            echo "  - Tag must match pattern: ${{ inputs.allowed_version_pattern }}"
            if [ "${{ inputs.verify_image_existence }}" = "true" ]; then
              echo "  - Image must exist in the registry"
            fi
            echo ""
            echo "Please use a valid image and try again."
            exit 1
          fi

          echo "‚úÖ All enabled validations passed!"

          # Show validated images if available
          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          if [ -n "$NEW_IMAGES" ] && [ "$NEW_IMAGES" != "[]" ]; then
            echo ""
            echo "The following images were validated and approved:"
            echo "$NEW_IMAGES" | jq -r '.[]' 2>/dev/null | while IFS= read -r img; do
              echo "  ‚úÖ $img"
            done
          fi

      - name: Create PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const shouldBypass = '${{ needs.check-team-membership.outputs.should-bypass }}' === 'true';
            const isTeamMember = '${{ needs.check-team-membership.outputs.is-team-member }}' === 'true';
            const prAuthor = '${{ needs.check-team-membership.outputs.pr-author }}';
            const matchedTeam = '${{ needs.check-team-membership.outputs.matched-team }}';
            const trustedTeams = '${{ inputs.trusted_github_teams }}';

            let commentBody = '## üõ°Ô∏è Deployment Guard Validation\n\n';

            // Permission-based bypass status
            commentBody += '### üë§ Author Verification\n';
            if (shouldBypass && isTeamMember) {
              commentBody += `‚úÖ **TRUSTED USER** - @${prAuthor}\n\n`;
              commentBody += `- Permission Level: \`${matchedTeam}\`\n`;
              if (trustedTeams) {
                commentBody += `- Trusted teams (reference): \`${trustedTeams}\`\n`;
              }
              commentBody += `- Status: üöÄ **All validations bypassed**\n`;
              commentBody += `- Reason: Users with admin/maintain permissions are fully trusted\n\n`;
              commentBody += '> **Note:** Due to GitHub API limitations, we verify repository permissions instead of direct team membership. ';
              commentBody += 'Users with admin or maintain permissions can bypass validations. ';
              commentBody += 'These permissions typically align with membership in trusted teams.\n\n';
              commentBody += '---\n\n';
              commentBody += '### ‚úÖ Validation Complete\n\n';
              commentBody += 'This PR was automatically approved based on repository permissions.\n\n';
              commentBody += 'No additional validation was required.\n';
            } else {
              commentBody += `‚ÑπÔ∏è  **STANDARD USER** - @${prAuthor}\n\n`;
              commentBody += `- Status: üîí **Full validation enforced**\n`;
              commentBody += `- All deployment rules must be satisfied\n\n`;

              const filesCheck = '${{ needs.validate-changed-files.outputs.allowed-files-check }}';
              const imageOnlyCheck = '${{ needs.validate-image-only-changed.outputs.image-only-check }}';
              const imageValidation = '${{ needs.validate-images.outputs.image-validation }}';
              const newImages = JSON.parse('${{ needs.validate-image-only-changed.outputs.new-images }}' || '[]');

              // Files check
              commentBody += '### üìÅ File Allowlist Check\n';
              if (filesCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - All modified files are in the allowlist\n\n';
              } else if (filesCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Some files are not in the allowlist\n\n';
                commentBody += `Only files matching \`${{ inputs.allowed_files_pattern }}\` can be modified.\n\n`;
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - File allowlist check not enabled\n\n';
              }

              // Image-only check
              commentBody += '### üîÑ Image-Only Change Check\n';
              if (imageOnlyCheck === 'pass') {
                commentBody += '‚úÖ **PASSED** - Only image field was modified\n\n';
              } else if (imageOnlyCheck === 'fail') {
                commentBody += '‚ùå **FAILED** - Changes detected beyond image field\n\n';
                commentBody += 'Only the dotCMS container image can be modified. No other fields are allowed.\n\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image-only check not enabled\n\n';
              }

              // Image validation
              commentBody += '### üê≥ Image Validation\n';
              if (imageValidation === 'pass') {
                commentBody += '‚úÖ **PASSED** - All images validated successfully\n\n';
                if (newImages.length > 0) {
                  commentBody += '**Validated images:**\n';
                  newImages.forEach(img => {
                    commentBody += `- \`${img}\`\n`;
                  });
                }
              } else if (imageValidation === 'fail') {
                commentBody += '‚ùå **FAILED** - Image validation failed\n\n';
                commentBody += `**Requirements:**\n`;
                if ('${{ inputs.allowed_image_repositories }}') {
                  commentBody += `- Repository must be: \`${{ inputs.allowed_image_repositories }}\`\n`;
                }
                commentBody += `- Tag must match pattern: \`${{ inputs.allowed_version_pattern }}\`\n`;
                if ('${{ inputs.verify_image_existence }}' === 'true') {
                  commentBody += `- Image must exist in the registry\n`;
                }
                commentBody += '\n';
              } else {
                commentBody += '‚ÑπÔ∏è  **SKIPPED** - Image validation not enabled\n\n';
              }

              // Final status
              commentBody += '\n---\n\n';
              if (filesCheck === 'pass' && imageOnlyCheck === 'pass' && imageValidation === 'pass') {
                commentBody += '### ‚úÖ All validations passed!\n\n';
                commentBody += 'This PR meets all deployment requirements.\n';
              } else {
                commentBody += '### ‚ùå Validation failed\n\n';
                commentBody += 'Please address the issues above and push new commits to re-trigger validation.\n';
              }
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
