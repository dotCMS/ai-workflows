---
name: Deutsche Bank Deployment Guard

on:
  workflow_call:
    inputs:
      allowed_files_pattern:
        description: 'Glob pattern for allowed files (e.g., kubernetes/dotcms/**/statefulset.yaml)'
        required: true
        type: string
      allowed_image_repositories:
        description: 'Comma-separated list of allowed image repositories (e.g., dotcms/dotcms)'
        required: true
        type: string
      allowed_version_pattern:
        description: 'Regex pattern for allowed version tags (default: date-based YY.MM.DD where YY >= 25)'
        required: false
        type: string
        default: '^(2[5-9]|[3-9][0-9])\.[0-9]{2}\.[0-9]{2}'
      verify_image_existence:
        description: 'Whether to verify image exists in registry'
        required: false
        type: boolean
        default: true

jobs:
  validate-changed-files:
    name: Validate Changed Files
    runs-on: ubuntu-latest
    outputs:
      allowed-files-check: ${{ steps.check-files.outputs.result }}
      changed-files: ${{ steps.get-files.outputs.files }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: get-files
        run: |
          # Get list of changed files in the PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            BASE_SHA="origin/${{ github.event.repository.default_branch }}"
            HEAD_SHA="HEAD"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep -E '\.ya?ml$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No YAML files changed"
            echo "files=" >> "$GITHUB_OUTPUT"
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert to JSON array for output
            FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "files=$FILES_JSON" >> "$GITHUB_OUTPUT"
          fi

      - name: Check files against allowlist
        id: check-files
        run: |
          CHANGED_FILES='${{ steps.get-files.outputs.files }}'
          ALLOWED_PATTERN='${{ inputs.allowed_files_pattern }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Validating files against pattern: $ALLOWED_PATTERN"

          # Convert glob pattern to regex
          # Replace ** with .*
          # Replace * with [^/]*
          PATTERN_REGEX=$(echo "$ALLOWED_PATTERN" | sed 's|\*\*|.*|g' | sed 's|\*|[^/]*|g')

          ALL_ALLOWED=true
          DISALLOWED_FILES=""

          echo "$CHANGED_FILES" | jq -r '.[]' | while IFS= read -r file; do
            if ! echo "$file" | grep -qE "^${PATTERN_REGEX}$"; then
              echo "‚ùå File not allowed: $file"
              echo "$file" >> /tmp/disallowed_files.txt
              ALL_ALLOWED=false
            else
              echo "‚úÖ File allowed: $file"
            fi
          done

          if [ -f /tmp/disallowed_files.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "‚ùå Some files are not in the allowlist"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files are in the allowlist"
          fi

  validate-image-only-changed:
    name: Validate Only Image Changed
    runs-on: ubuntu-latest
    needs: validate-changed-files
    if: needs.validate-changed-files.outputs.allowed-files-check == 'pass'
    outputs:
      image-only-check: ${{ steps.check-changes.outputs.result }}
      new-images: ${{ steps.check-changes.outputs.images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check only image field changed
        id: check-changes
        run: |
          CHANGED_FILES='${{ needs.validate-changed-files.outputs.changed-files }}'

          if [ "$CHANGED_FILES" = "" ] || [ "$CHANGED_FILES" = "[]" ]; then
            echo "No files to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          NEW_IMAGES=()
          ALL_PASS=true

          echo "$CHANGED_FILES" | jq -r '.[]' | while IFS= read -r file; do
            echo "=================================================="
            echo "Validating: $file"
            echo "=================================================="

            # Get old and new YAML content
            OLD_YAML=$(git show "$BASE_SHA:$file" 2>/dev/null || echo "")
            NEW_YAML=$(cat "$file")

            if [ -z "$OLD_YAML" ]; then
              echo "‚ö†Ô∏è  File is new, skipping comparison"
              continue
            fi

            # Extract the main dotCMS container image
            OLD_IMAGE=$(echo "$OLD_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")
            NEW_IMAGE=$(echo "$NEW_YAML" | yq '.spec.template.spec.containers[] | select(.name == "dotcms") | .image' 2>/dev/null || echo "")

            if [ -z "$OLD_IMAGE" ] || [ -z "$NEW_IMAGE" ]; then
              echo "‚ùå Could not extract dotCMS container image"
              ALL_PASS=false
              echo "false" > /tmp/validation_failed.txt
              continue
            fi

            echo "Old image: $OLD_IMAGE"
            echo "New image: $NEW_IMAGE"

            # Normalize both YAMLs by replacing the dotCMS image with placeholder
            OLD_NORMALIZED=$(echo "$OLD_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')
            NEW_NORMALIZED=$(echo "$NEW_YAML" | yq '(.spec.template.spec.containers[] | select(.name == "dotcms") | .image) = "PLACEHOLDER"')

            # Compare normalized YAMLs
            if [ "$OLD_NORMALIZED" != "$NEW_NORMALIZED" ]; then
              echo "‚ùå Changes detected beyond image field in: $file"
              echo ""
              echo "Diff of normalized files:"
              diff <(echo "$OLD_NORMALIZED") <(echo "$NEW_NORMALIZED") || true
              ALL_PASS=false
              echo "false" > /tmp/validation_failed.txt
            else
              echo "‚úÖ Only image changed: $OLD_IMAGE ‚Üí $NEW_IMAGE"
              echo "$NEW_IMAGE" >> /tmp/new_images.txt
            fi
            echo ""
          done

          if [ -f /tmp/validation_failed.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            echo "images=[]" >> "$GITHUB_OUTPUT"
            exit 1
          else
            if [ -f /tmp/new_images.txt ]; then
              IMAGES_JSON=$(cat /tmp/new_images.txt | jq -R -s -c 'split("\n") | map(select(length > 0)) | unique')
              echo "images=$IMAGES_JSON" >> "$GITHUB_OUTPUT"
            else
              echo "images=[]" >> "$GITHUB_OUTPUT"
            fi
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All files have only image field changes"
          fi

  validate-images:
    name: Validate Images
    runs-on: ubuntu-latest
    needs: validate-image-only-changed
    if: needs.validate-image-only-changed.outputs.image-only-check == 'pass'
    outputs:
      image-validation: ${{ steps.validate.outputs.result }}
    steps:
      - name: Validate image format, repository, tag, and existence
        id: validate
        run: |
          NEW_IMAGES='${{ needs.validate-image-only-changed.outputs.new-images }}'
          ALLOWED_REPOS='${{ inputs.allowed_image_repositories }}'
          VERSION_PATTERN='${{ inputs.allowed_version_pattern }}'
          VERIFY_EXISTENCE='${{ inputs.verify_image_existence }}'

          if [ "$NEW_IMAGES" = "" ] || [ "$NEW_IMAGES" = "[]" ]; then
            echo "No new images to validate"
            echo "result=pass" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ALL_VALID=true

          echo "$NEW_IMAGES" | jq -r '.[]' | while IFS= read -r image; do
            echo "=================================================="
            echo "Validating image: $image"
            echo "=================================================="

            # 1. Validate format (repo/name:tag)
            if ! [[ "$image" =~ ^[a-zA-Z0-9_/-]+:[a-zA-Z0-9._-]+$ ]]; then
              echo "‚ùå Invalid image format: $image"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Image format is valid"

            # 2. Extract repository and tag
            REPO="${image%:*}"
            TAG="${image##*:}"
            echo "   Repository: $REPO"
            echo "   Tag: $TAG"

            # 3. Check repository is in allowlist
            REPO_ALLOWED=false
            IFS=',' read -ra ALLOWED <<< "$ALLOWED_REPOS"
            for allowed_repo in "${ALLOWED[@]}"; do
              # Trim whitespace
              allowed_repo=$(echo "$allowed_repo" | xargs)
              if [[ "$REPO" == "$allowed_repo" ]]; then
                REPO_ALLOWED=true
                break
              fi
            done

            if [ "$REPO_ALLOWED" = false ]; then
              echo "‚ùå Repository not allowed: $REPO"
              echo "   Allowed repositories: $ALLOWED_REPOS"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Repository is allowed"

            # 4. Validate tag matches version pattern
            if ! [[ "$TAG" =~ $VERSION_PATTERN ]]; then
              echo "‚ùå Tag does not match version pattern: $TAG"
              echo "   Expected pattern: $VERSION_PATTERN"
              echo "   This typically means: date-based versions YY.MM.DD where YY >= 25"
              echo "false" > /tmp/validation_failed.txt
              continue
            fi
            echo "‚úÖ Tag matches version pattern"

            # 5. Verify image exists in registry (optional)
            if [ "$VERIFY_EXISTENCE" = "true" ]; then
              echo "Verifying image exists in registry..."
              if docker manifest inspect "$image" >/dev/null 2>&1; then
                echo "‚úÖ Image exists in registry"
              else
                echo "‚ùå Image does not exist in registry: $image"
                echo "false" > /tmp/validation_failed.txt
                continue
              fi
            fi

            echo "‚úÖ Image validated successfully: $image"
            echo ""
          done

          if [ -f /tmp/validation_failed.txt ]; then
            echo "result=fail" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "result=pass" >> "$GITHUB_OUTPUT"
            echo "‚úÖ All images validated successfully"
          fi

  finalize:
    name: Final Status
    runs-on: ubuntu-latest
    needs: [validate-changed-files, validate-image-only-changed, validate-images]
    if: always()
    steps:
      - name: Check all validations
        run: |
          FILES_CHECK="${{ needs.validate-changed-files.outputs.allowed-files-check }}"
          IMAGE_ONLY_CHECK="${{ needs.validate-image-only-changed.outputs.image-only-check }}"
          IMAGE_VALIDATION="${{ needs.validate-images.outputs.image-validation }}"

          echo "=================================================="
          echo "Validation Results Summary"
          echo "=================================================="
          echo "Files allowlist check: $FILES_CHECK"
          echo "Image-only change check: $IMAGE_ONLY_CHECK"
          echo "Image validation: $IMAGE_VALIDATION"
          echo "=================================================="

          if [ "$FILES_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Modified files are not in the allowlist"
            echo ""
            echo "Only the following files can be modified:"
            echo "  - ${{ inputs.allowed_files_pattern }}"
            echo ""
            echo "Please ensure you're only modifying allowed StatefulSet files."
            exit 1
          fi

          if [ "$IMAGE_ONLY_CHECK" != "pass" ]; then
            echo "‚ùå BLOCKED: Changes detected beyond the image field"
            echo ""
            echo "Only the dotCMS container image field can be modified."
            echo "No other changes are allowed (resources, env vars, volumes, etc.)"
            echo ""
            echo "Please revert any non-image changes and try again."
            exit 1
          fi

          if [ "$IMAGE_VALIDATION" != "pass" ]; then
            echo "‚ùå BLOCKED: Image validation failed"
            echo ""
            echo "Image validation requirements:"
            echo "  - Repository must be: ${{ inputs.allowed_image_repositories }}"
            echo "  - Tag must match pattern: ${{ inputs.allowed_version_pattern }}"
            echo "  - Image must exist in the registry"
            echo ""
            echo "Please use a valid image and try again."
            exit 1
          fi

          echo "‚úÖ All validations passed!"
          echo ""
          echo "The following images were validated and approved:"
          echo '${{ needs.validate-image-only-changed.outputs.new-images }}' | jq -r '.[]' | while read img; do
            echo "  ‚úÖ $img"
          done

      - name: Create PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const filesCheck = '${{ needs.validate-changed-files.outputs.allowed-files-check }}';
            const imageOnlyCheck = '${{ needs.validate-image-only-changed.outputs.image-only-check }}';
            const imageValidation = '${{ needs.validate-images.outputs.image-validation }}';
            const newImages = JSON.parse('${{ needs.validate-image-only-changed.outputs.new-images }}');

            let commentBody = '## üõ°Ô∏è Deutsche Bank Deployment Validation\n\n';

            // Files check
            commentBody += '### üìÅ File Allowlist Check\n';
            if (filesCheck === 'pass') {
              commentBody += '‚úÖ **PASSED** - All modified files are in the allowlist\n\n';
            } else {
              commentBody += '‚ùå **FAILED** - Some files are not in the allowlist\n\n';
              commentBody += `Only files matching \`${{ inputs.allowed_files_pattern }}\` can be modified.\n\n`;
            }

            // Image-only check
            commentBody += '### üîÑ Image-Only Change Check\n';
            if (imageOnlyCheck === 'pass') {
              commentBody += '‚úÖ **PASSED** - Only image field was modified\n\n';
            } else {
              commentBody += '‚ùå **FAILED** - Changes detected beyond image field\n\n';
              commentBody += 'Only the dotCMS container image can be modified. No other fields are allowed.\n\n';
            }

            // Image validation
            commentBody += '### üê≥ Image Validation\n';
            if (imageValidation === 'pass') {
              commentBody += '‚úÖ **PASSED** - All images validated successfully\n\n';
              if (newImages.length > 0) {
                commentBody += '**Validated images:**\n';
                newImages.forEach(img => {
                  commentBody += `- \`${img}\`\n`;
                });
              }
            } else {
              commentBody += '‚ùå **FAILED** - Image validation failed\n\n';
              commentBody += `**Requirements:**\n`;
              commentBody += `- Repository must be: \`${{ inputs.allowed_image_repositories }}\`\n`;
              commentBody += `- Tag must match pattern: \`${{ inputs.allowed_version_pattern }}\`\n`;
              commentBody += `- Image must exist in the registry\n\n`;
            }

            // Final status
            commentBody += '\n---\n\n';
            if (filesCheck === 'pass' && imageOnlyCheck === 'pass' && imageValidation === 'pass') {
              commentBody += '### ‚úÖ All validations passed!\n\n';
              commentBody += 'This PR is approved to merge (subject to standard review process).\n';
            } else {
              commentBody += '### ‚ùå Validation failed\n\n';
              commentBody += 'Please address the issues above and push new commits to re-trigger validation.\n';
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
